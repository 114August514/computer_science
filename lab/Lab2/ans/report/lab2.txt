### Lab2

- 姓名：林佳胜；学号：PB24511997

---

#### 简要描述

- 通过 **LEA** 将 **Q_ARRAY** 的起始位置存储在 $ R_0 $ ，然后使用 $ADD~R_0,~R_0,~\#-1$ 指令，

    保证之后访问 **Q[n]** 的地址时符合 $R_0 + n$ 的逻辑。

- 存储时发现 **STR** 的基址偏移无法处理 100 的数量级，后考虑动态存储，用 $R_7 = R_0 + n$ 实现获取 **&Q[n]** ；

- 加载与存储的逻辑类似（虽然实现上是先写的加载，再写的存储），通过 **LDR** 基址偏移获取 **Q[n - Q[n-2]]**、**Q[n - Q[n-1]]**。

- （用 **R1**, **R2** 来存 **Q[n-2]**, **Q[n-1]**，减少了对内存的访问操作，进一步优化了代码效率）

- （.asm 里的注释还算丰富）

#### 测试样例

- 在 **N = 100** 时，结果如图所示：

    ![img](lab2.assets/aa526823-7a0c-42dd-aa0f-036e7b307e70.png)

    

- | **N** | **Q[n]** |
    | ----- | -------- |
    | 50    | 25       |
    | 90    | 48       |
    | 100   | 56       |

#### 遇到困难

- - （该条不严格算问题，只算程序的优化）一开始打算是在主程序附近放一个指针指向数据存储区域，然后用 **LDI** 间接访问，以实现对 **x3100** 内存区域的访问。
    - **优化**：经过对 **LD** 访问区域的考量，发现其一开始就能访问到 **x3100** ，于是换用 **LD** 进行了代码效率的优化。
- - 在循环过程中，因为中间量过多，导致一开始写的时候寄存器数超了（写到 $R_8$ 没有渲染看出来的）
    - **解决**：发现 **R_5**、**R_6** 本身一直存储的是中间值，且该中间值仅需存在较短时间，允许被覆盖，于是通过重复利用寄存器来缓解了寄存器数目较少的压力。