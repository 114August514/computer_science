## HW2

---

### 一. 选择题

1. B;
2. A;
3. D;
4. C;

---

### 二. 算法设计题

1. ```c
    void mergeList(Point* head1, Point* head2, Point* merged_head)
    {
        // 预设head1和head2都是升序排列的
        // merged_head 要求是降序排列（故采用头插法）
        // 注意：链表的头结点都是哑元（不存储实际数据，仅用于简化操作）
        Point* p1 = head1->next;
        Point* p2 = head2->next;
        Point* head = merged_head;
        Point* temp = NULL;
        head->next = NULL;
    
        while (p1 != NULL && p2 != NULL)
        {
            if (p1->value < p2->value)
            {
                temp = p1->next;
                p1->next = head->next;
                head->next = p1;
                p1 = temp;
            }
            else
            {
                temp = p2->next;
                p2->next = head->next;
                head->next = p2;
                p2 = temp;
            }
        }
    
        // 处理剩余节点
        Point* p = (p1==NULL) ? p2 : p1;
        while (p != NULL)
        {
            temp = p->next;
            p->next = head->next;
            head->next = p;
            p = temp;
        }
    
        // 安全行为
        head1->next = NULL;
        head2->next = NULL;
    }
    ```

2.  ```c
    void reverseList(Point* head)
    {
        // 链表的头结点依旧是哑元
        Point* past = NULL;
        Point* current = head->next;
        Point* future = NULL;
    
        while (current != NULL)
        {
            future = current->next;
            current->next = past;
            past = current;
            current = future;
        }
    
        head->next = past;
    }
    ```

